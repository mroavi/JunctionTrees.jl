var documenterSearchIndex = {"docs":
[{"location":"visualization/markov_random_fields/#Visualization-of-Markov-random-fields","page":"Markov random fields","title":"Visualization of Markov random fields","text":"","category":"section"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"The Markov random fields used in JunctionTrees.jl can be conveniently visualized with GraphMakie.jl. This document presents a series of examples that illustrate different possibilities of plotting this type of graphs.","category":"page"},{"location":"visualization/markov_random_fields/#Example-1","page":"Markov random fields","title":"Example 1","text":"","category":"section"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"Plots a Markov random field with no node labels.","category":"page"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"using JunctionTrees, CairoMakie, GraphMakie\n\nnvars, _, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 300))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(ax, mrf, layout = GraphMakie.NetworkLayout.Stress(seed=1))\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/markov_random_fields/#","page":"Markov random fields","title":"","text":"","category":"section"},{"location":"visualization/markov_random_fields/#Example-2","page":"Markov random fields","title":"Example 2","text":"","category":"section"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"Plots a Markov random field with variable IDs as node labels.","category":"page"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf\n\nnvars, _, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 300))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  mrf,\n  layout = GraphMakie.NetworkLayout.Stress(seed=1),\n  nlabels = [@sprintf \"%i\" v for v in vertices(mrf)],\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 25,\n)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/markov_random_fields/#-2","page":"Markov random fields","title":"","text":"","category":"section"},{"location":"visualization/markov_random_fields/#Example-3","page":"Markov random fields","title":"Example 3","text":"","category":"section"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"Plots a Markov random field with variable IDs as node labels. Observed variables are colored in red.","category":"page"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, ColorSchemes\n\nnvars, _, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nobsvars, obsvals = JunctionTrees.read_uai_evid_file(\"../problems/paskin/paskin.uai.evid\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\n\n# Default node color\nnode_color = [ColorSchemes.watermelon[1] for i in 1:nv(mrf)]\n\n# Observed node color\nnode_color[obsvars] .= ColorSchemes.watermelon[8]\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 300))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  mrf,\n  layout = GraphMakie.NetworkLayout.Stress(seed=1),\n  nlabels = [@sprintf \"%i\" v for v in vertices(mrf)],\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 25,\n  node_color = node_color,\n)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/markov_random_fields/#-3","page":"Markov random fields","title":"","text":"","category":"section"},{"location":"visualization/markov_random_fields/#Example-4","page":"Markov random fields","title":"Example 4","text":"","category":"section"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"Plots a Markov random field of problem 34 of the Promedus benchmark.","category":"page"},{"location":"visualization/markov_random_fields/","page":"Markov random fields","title":"Markov random fields","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, ColorSchemes\n\nnvars, _, _, factors = JunctionTrees.read_uai_file(\"../problems/Promedus_34/Promedus_34.uai\")\nobsvars, obsvals = JunctionTrees.read_uai_evid_file(\"../problems/Promedus_34/Promedus_34.uai.evid\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\n\n# Default node color\nnode_color = [ColorSchemes.watermelon[1] for i in 1:nv(mrf)]\n\n# Observed node color\nnode_color[obsvars] .= ColorSchemes.watermelon[8]\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 600))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(ax, mrf, layout = GraphMakie.NetworkLayout.Stress(seed=1), node_color = node_color)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This section presents a series of examples that illustrate different uses of JunctionTrees.jl. Load the package to run the examples.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using JunctionTrees","category":"page"},{"location":"usage/#Example-1","page":"Usage","title":"Example 1","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Calculates the posterior marginals of each variable in the input graph. The input graph should be defined in the UAI model file format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"algo = compile_algo(\"problems/asia/asia.uai\")\neval(algo)\nobsvars, obsvals = Int64[], Int64[]\nmarginals = run_algo(obsvars, obsvals)","category":"page"},{"location":"usage/#Example-2","page":"Usage","title":"Example 2","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Calculates the posterior marginals of each variable in the input graph given some evidence. The input graph should be defined in the UAI model file format. The evidence variables and values should be given in the UAI evidence file format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"algo = compile_algo(\n         \"problems/asia/asia.uai\",\n         uai_evid_filepath = \"problems/asia/asia.uai.evid\")\neval(algo)\nobsvars, obsvals = JunctionTrees.read_uai_evid_file(\"problems/asia/asia.uai.evid\")\nmarginals = run_algo(obsvars, obsvals)","category":"page"},{"location":"usage/#Example-3","page":"Usage","title":"Example 3","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Same as the previous example with the difference that a pre-constructed junction tree (which is passed as an argument) is used. This junction tree should be defined in the PACE graph format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"algo = compile_algo(\n         \"problems/asia/asia.uai\",\n         uai_evid_filepath = \"problems/asia/asia.uai.evid\",\n         td_filepath = \"problems/asia/asia.td\")\neval(algo)\nobsvars, obsvals = JunctionTrees.read_uai_evid_file(\"problems/asia/asia.uai.evid\")\nmarginals = run_algo(obsvars, obsvals)","category":"page"},{"location":"usage/#Example-4","page":"Usage","title":"Example 4","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Returns the expression of the junction tree algorithm up to the backward pass stage.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"backward_pass_expr = compile_algo( \"problems/asia/asia.uai\", last_stage = BackwardPass)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The stages supported are:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"instances(LastStage)","category":"page"},{"location":"file_formats/pace/#PACE-files-format","page":"PACE","title":"PACE files format","text":"","category":"section"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"This document defines the following file formats:","category":"page"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"PACE graph format.\nPACE tree decomposition format.","category":"page"},{"location":"file_formats/pace/#PACE-graph-format","page":"PACE","title":"PACE graph format","text":"","category":"section"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"We describe the file format .gr, which is similar to the format used by DIMACS challenges.","category":"page"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"Lines are separated by the character ‘\\n’. Each line that starts with the character c is considered to be a comment line. The first non-comment line must be a line starting with p followed by the problem descriptor tw and the number of vertices n and edges m (separated by a single space each time). No other line may start with p. Every other line indicates an edge, and must consist of two decimal integers from 1 to n separated by a space; moreover, graphs are considered undirected (though they may contain isolated vertices, multiple edges, and loops). For example, a path with four edges can be defined as follows:","category":"page"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"c This file describes a path with five vertices and four edges.\np tw 5 4\n1 2\n2 3\nc we are half-way done with the instance definition.\n3 4\n4 5","category":"page"},{"location":"file_formats/pace/#PACE-tree-decomposition-format","page":"PACE","title":"PACE tree decomposition format","text":"","category":"section"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"Recall the definition of a tree decomposition of a graph G: It is a tree T such that every vertex x in V(T) has an associated bag B(x) that is a subset of V(G). Every edge e in E(G) must be a subset of at least one bag B(x). Moreover, for every vertex v in V(G), the set of tree vertices whose bags contain v induce a connected subtree of T. The width of T is the maximum size of its bags minus one. The goal is to compute a tree decomposition of minimum width.","category":"page"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"We define the file format .td. As above, c lines are comments and can occur throughout the file. Instead of a p-line, we now expect a unique solution line s as the first non-comment line, which contains the string td, followed by the number N of bags of the tree decomposition, the width of the tree decomposition plus one (i.e., the largest bag size), as well as the number of vertices of the original input graph. The next non-comment lines we expect start with b and specify the contents of each bag; for example, b 4 3 4 6 7 specifies that bag number 4 contains the vertices 3, 4, 6, and 7 of the original graph. Bags may be empty. For every bag i, there must be exactly one line starting with b i. All remaining non-comment lines indicate an edge in the tree decomposition, so it must consist of two decimal integers from 1 and N where the first integer is smaller than the second, and the graph described this way must be a tree. For example, the following is a suboptimal tree decomposition of the path with four edges.","category":"page"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"c This file describes a tree decomposition with 4 bags, width 2, for a graph with 5 vertices\ns td 4 3 5\nb 1 1 2 3\nb 2 2 3 4\nb 3 3 4 5\nb 4\n1 2\n2 3\n2 4","category":"page"},{"location":"file_formats/pace/#Validity-checker","page":"PACE","title":"Validity checker","text":"","category":"section"},{"location":"file_formats/pace/","page":"PACE","title":"PACE","text":"The validity checker at https://github.com/holgerdell/td-validate/ verifies that a given tree decomposition (specified in the .td file format) is indeed a valid tree decomposition of a given graph (specified in the .gr format). The validity checker will be used to evaluate whether your submitted implementation computed a correct tree decomposition.","category":"page"},{"location":"visualization/junction_trees/#Visualization-of-junction-trees","page":"Junction trees","title":"Visualization of junction trees","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"The junction trees used in JunctionTrees.jl can be conveniently visualized with GraphMakie.jl. This document presents a series of examples that illustrate different possibilities of plotting this type of graphs.","category":"page"},{"location":"visualization/junction_trees/#Example-1","page":"Junction trees","title":"Example 1","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with no node or edge labels.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 300))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(ax, td, layout = GraphMakie.NetworkLayout.Stress(seed=58))\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-2","page":"Junction trees","title":"Example 2","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster IDs as node labels.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 300))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = [@sprintf \"%i\" v for v in vertices(td)],\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 25,\n)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-2","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-3","page":"Junction trees","title":"Example 3","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster variables as node labels.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, MetaGraphs\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 400))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = map(vertex -> get_prop(td, vertex, :vars), vertices(td)) |> x -> string.(x),\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 80,\n)\n\nxlims!(-1.5, 1.5)\nylims!(-0.9, 1.4)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-3","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-4","page":"Junction trees","title":"Example 4","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster IDs and cluster variables as node labels.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, MetaGraphs\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\n# Node labels\nnodeids = vertices(td) |> collect |> x -> string.(x)\nvarscopes = map(vertex -> get_prop(td, vertex, :vars), vertices(td)) |> x -> string.(x)\nnlabels = zip(nodeids, varscopes) |> x -> map( y -> y[1]*\": \"*y[2], x)\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 400))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = nlabels,\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 100,\n)\n\nxlims!(-1.5, 1.5)\nylims!(-0.9, 1.4)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-4","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-5","page":"Junction trees","title":"Example 5","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster IDs and cluster variables as node labels. The root cluster is denoted with a fisheye lens-like circle.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, MetaGraphs\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\n# Node labels\nnodeids = vertices(td) |> collect |> x -> string.(x)\nvarscopes = map(vertex -> get_prop(td, vertex, :vars), vertices(td)) |> x -> string.(x)\nnlabels = zip(nodeids, varscopes) |> x -> map( y -> y[1]*\": \"*y[2], x)\n\n# Root node shape\nnode_marker = repeat(['●'], nv(td))\nnode_marker[JunctionTrees.select_rootnode(td).id] = '◉'\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 500))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = nlabels,\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 160,\n  node_marker = node_marker,\n)\n\nxlims!(-1.5, 1.5)\nylims!(-0.9, 1.5)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-5","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-6","page":"Junction trees","title":"Example 6","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster IDs and cluster variables as node labels. The root cluster is denoted with a fisheye lens-like circle. Clusters with one or more observed variables are colored in red.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, MetaGraphs, ColorSchemes\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nobsvars, _ = JunctionTrees.read_uai_evid_file(\"../problems/paskin/paskin.uai.evid\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\n# Node labels\nnodeids = vertices(td) |> collect |> x -> string.(x)\nvarscopes = map(vertex -> get_prop(td, vertex, :vars), vertices(td)) |> x -> string.(x)\nnlabels = zip(nodeids, varscopes) |> x -> map( y -> y[1]*\": \"*y[2], x)\n\n# Root node shape\nnode_marker = repeat(['●'], nv(td))\nnode_marker[JunctionTrees.select_rootnode(td).id] = '◉'\n\n# Default node color\nnode_color = [ColorSchemes.watermelon[1] for i in 1:nv(td)]\n\n# Observed node color\nnode_color[obsvars] .= ColorSchemes.watermelon[8]\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 500))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = nlabels,\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 160,\n  node_marker = node_marker,\n  node_color = node_color,\n)\n\nxlims!(-1.5, 1.5)\nylims!(-0.9, 1.4)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-6","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-7","page":"Junction trees","title":"Example 7","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree with cluster IDs and cluster variables as node labels and sepsets as edge labels. The root cluster is denoted with a fisheye lens-like circle. Clusters with one or more observed variables are colored in red.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, Printf, MetaGraphs, ColorSchemes\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/paskin/paskin.uai\")\nobsvars, _ = JunctionTrees.read_uai_evid_file(\"../problems/paskin/paskin.uai.evid\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\n# Node labels\nnodeids = vertices(td) |> collect |> x -> string.(x)\nvarscopes = map(vertex -> get_prop(td, vertex, :vars), vertices(td)) |> x -> string.(x)\nnlabels = zip(nodeids, varscopes) |> x -> map( y -> y[1]*\": \"*y[2], x)\n\n# Root node shape\nnode_marker = repeat(['●'], nv(td))\nnode_marker[JunctionTrees.select_rootnode(td).id] = '◉'\n\n# Default node color\nnode_color = [ColorSchemes.watermelon[1] for i in 1:nv(td)]\n\n# Observed node color\nnode_color[obsvars] .= ColorSchemes.watermelon[8]\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 500))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(\n  ax,\n  td,\n  layout = GraphMakie.NetworkLayout.Stress(seed=58),\n  nlabels = nlabels,\n  nlabels_align = (:center,:center),\n  nlabels_color = :white,\n  nlabels_textsize = 14,\n  node_size = 160,\n  node_marker = node_marker,\n  node_color = node_color,\n  elabels = [repr(sepset) for sepset in map(edge -> get_prop(td, edge, :sepset), edges(td))],\n  elabels_textsize = 14,\n  elabels_align = (:center, :bottom),\n  elabels_distance = 5.0,\n)\n\nxlims!(-1.5, 1.5)\nylims!(-0.9, 1.4)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"visualization/junction_trees/#-7","page":"Junction trees","title":"","text":"","category":"section"},{"location":"visualization/junction_trees/#Example-8","page":"Junction trees","title":"Example 8","text":"","category":"section"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"Plots a junction tree based on problem 34 of the Promedus benchmark.","category":"page"},{"location":"visualization/junction_trees/","page":"Junction trees","title":"Junction trees","text":"using JunctionTrees, CairoMakie, GraphMakie, Graphs, MetaGraphs, ColorSchemes\n\nnvars, cards, _, factors = JunctionTrees.read_uai_file(\"../problems/Promedus_34/Promedus_34.uai\")\nobsvars, _ = JunctionTrees.read_uai_evid_file(\"../problems/Promedus_34/Promedus_34.uai.evid\")\nmrf = JunctionTrees.construct_mrf_graph(nvars, factors)\ntd = JunctionTrees.construct_td_graph(mrf, cards)\n\n# Default node color\nnode_color = [ColorSchemes.watermelon[1] for i in 1:nv(td)]\n\n# Root node color\nnode_color[JunctionTrees.select_rootnode(td).id] = ColorSchemes.watermelon[3]\n\n# Observed node color\nnode_color[obsvars] .= ColorSchemes.watermelon[8]\n\nfig = Figure(backgroundcolor = :white, resolution=(900, 600))\nax = fig[1,:] = Axis(fig, backgroundcolor = :white)\n\ngraphplot!(ax, td, layout = GraphMakie.NetworkLayout.Stress(seed=1), node_color = node_color)\n\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nfig","category":"page"},{"location":"library/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Documentation for JunctionTrees.jl's internals.","category":"page"},{"location":"library/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Types","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nOrder = [:type]","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Functions","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nOrder = [:function]","category":"page"},{"location":"library/internals/#Internals-interface","page":"Internals","title":"Internals interface","text":"","category":"section"},{"location":"library/internals/#internals_Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nOrder   = [:type]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.Node","page":"Internals","title":"JunctionTrees.Node","text":"mutable struct Node{T}\n\nid::Any\nchildren::Array{JunctionTrees.Node{T}, 1} where T\nparent::JunctionTrees.Node\n\nTree node definition intended to be used with AbstractTrees.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#internals_Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nOrder   = [:function]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees._marg-NTuple{4, Any}","page":"Internals","title":"JunctionTrees._marg","text":"_marg(r_vals, ret_vars, Avals, dims) -> Factor\n\n\nPerformance critical code of the factor marginalization operation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees._product-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees._product","text":"_product(A_vals_new, B_vals_new, C_vars) -> Factor{Float64}\n\n\nPerformance critical code of the factor product operation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.add_edges!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.add_edges!","text":"add_edges!(g, edges)\n\n\nConstruct the edges and store their sepset as an edge property.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.add_vertices!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.add_vertices!","text":"add_vertices!(g, bags)\n\n\nAdd a vertex for each bag and initialize its properties.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.addchild!-Tuple{Any, JunctionTrees.Node}","page":"Internals","title":"JunctionTrees.addchild!","text":"addchild!(id, parent::JunctionTrees.Node) -> JunctionTrees.Node\n\n\nAdd a child node with id id to parent.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.addchildren!-Tuple{Any, JunctionTrees.Node}","page":"Internals","title":"JunctionTrees.addchildren!","text":"addchildren!(ids, parent::JunctionTrees.Node) -> Any\n\n\nAdd several children with with ids ids to parent.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.are_connected-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.are_connected","text":"are_connected(g, v1, v2) -> Bool\n\n\nReturn whether vertices v1 and v2 are connected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.assign_factors!-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.assign_factors!","text":"assign_factors!(g, factors, root)\n\n\nAssign each factor to a cluster that covers its variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.calculate_sepset_key-Tuple{MetaGraphs.MetaGraph, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.calculate_sepset_key","text":"calculate_sepset_key(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}, cards) -> Tuple{Int64, Int64}\n\n\nCalculate the \"key\" of sepset based on:\n\nMass: The number of variables in sepset.\nCost: The product of the cardinality of each variable in sepset.\n\nThe number of variables in the sepset has higher priority than the product of their cardinality. The higher the mass, the lower the key. The lower the cost, the lower the key.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.calculate_var_key-Tuple{MetaGraphs.MetaGraph, Int64, Any}","page":"Internals","title":"JunctionTrees.calculate_var_key","text":"calculate_var_key(g::MetaGraphs.MetaGraph, v::Int64, cards) -> Tuple{Int64, Int64}\n\n\nCalculate the \"key\" of v based on:\n\nThe number of edges to be added if v's neighbors were to be connected.\nThe weight of v and its neighbors (also known as the induced bag).\n\nThe number of edges to be added has more priority than the weight of the induced cluster. The lower the number of edges to be added, the lower the key. The lower the weight, the lower the key.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_backward_pass!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_backward_pass!","text":"compile_backward_pass!(g, root) -> Expr\n\n\nCompile the downstream messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_bag_potentials-Tuple{Any}","page":"Internals","title":"JunctionTrees.compile_bag_potentials","text":"compile_bag_potentials(g) -> Expr\n\n\nCompile each bag's potential into a Julia expression.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_forward_pass!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_forward_pass!","text":"compile_forward_pass!(g, root) -> Expr\n\n\nCompile the upstream messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_message_propagation!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_message_propagation!","text":"compile_message_propagation!(g, root) -> Tuple{Expr, Expr}\n\n\nCompile the forward and backward passes of messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_normalized_marginals-Tuple{Any}","page":"Internals","title":"JunctionTrees.compile_normalized_marginals","text":"compile_normalized_marginals(unnormalized_marginals) -> Expr\n\n\nCompile the normalized marginal expressions for each variable in the model.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_unnormalized_marginals-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.compile_unnormalized_marginals","text":"compile_unnormalized_marginals(g, nvars, partial_evaluation) -> Tuple{Expr, Expr, Expr}\n\n\nCompile marginalization statements for each variable from a sepset if possible and otherwise from a bag.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.connect_bags!-Tuple{MetaGraphs.MetaGraph, MetaGraphs.MetaGraph, Vector{Vector{Int64}}, Any}","page":"Internals","title":"JunctionTrees.connect_bags!","text":"connect_bags!(td::MetaGraphs.MetaGraph, mrf::MetaGraphs.MetaGraph, bags::Vector{Vector{Int64}}, cards)\n\n\nConnect the bags such that the running intersection property is satisfied.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.construct_mrf_graph-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.construct_mrf_graph","text":"construct_mrf_graph(nvars, factors) -> MetaGraphs.MetaGraph\n\n\nConstruct a Markov random field graph with nvars variables and the cliques contained in factors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.construct_td_graph-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.construct_td_graph","text":"construct_td_graph(mrf, cards) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nTransform the given Markov random field into a junction tree. This implementation is based on \"Inference in Belief Networks: A Procedural Guide\" by Cecil Huang and Adnan Darwiche (1996) pg. 235.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.construct_td_graph-Tuple{String}","page":"Internals","title":"JunctionTrees.construct_td_graph","text":"construct_td_graph(td_filepath::String) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nConstruct a tree decomposition graph based on td_filepath.\n\nThe td_filepath file format is defined in: https://pacechallenge.org/2017/treewidth/.\n\nExample\n\ntd_filepath = \"../problems/Promedus_26/Promedus_26.td\"\ntd = compile_algo(td_filepath)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.convertToAbstractTree!","page":"Internals","title":"JunctionTrees.convertToAbstractTree!","text":"convertToAbstractTree!(g, root::JunctionTrees.Node)\nconvertToAbstractTree!(g, root::JunctionTrees.Node, parent::JunctionTrees.Node)\n\n\nConstruct a tree decomposition abstract tree based on the graph g using root as the root node.\n\nExample\n\nusing Graphs\n\ng = double_binary_tree(3)\nroot = Node(1)\nconvertToAbstractTree!(g, root)\nprint_tree(root)\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#JunctionTrees.cost-Tuple{MetaGraphs.MetaGraph, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.cost","text":"cost(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}, cards) -> Int64\n\n\nCompute the product of the cardinalities of bag constituent vars.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.count_edges_to_be_added-Tuple{MetaGraphs.MetaGraph, Int64}","page":"Internals","title":"JunctionTrees.count_edges_to_be_added","text":"count_edges_to_be_added(g::MetaGraphs.MetaGraph, v::Int64) -> Int64\n\n\nCompute the number of edges to be added to the graph if we choose to eliminate this vertex.\n\nArguments\n\ng::MetaGraph the graph to consider.\nv::Int64 the vertex to eliminate.\n\nReturn\n\ncount::Int64 number of edges to add in the graph g if v is eliminated.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.form_bags-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.form_bags","text":"form_bags(g, cards) -> Vector{Vector{Int64}}\n\n\nReturn the maximal cliques of g using the minfill heuristic. The maximal cliques of the triangulated graph correspond to the bags of the junction tree. This implementation is based on: \"Inference in Belief Networks: A Procedural Guide\" by Cecil Huang and Adnan Darwiche (1996) pg. 235. TODO: See https://matbesancon.xyz/post/2019-05-30-vertex-safe-removal/ to implement this function using a vertex-safe version of Graphs.jl. This would avoid having to bookkeep the node ids in the original graph after it is modified with rev_vertex!.\n\nBookkepping example for the paskin-example problem:\n\n-----------------------------------------------------------\n| var to remove | vertices(g) | int2ext     | ext2int     |\n-----------------------------------------------------------\n| 6             | 1 2 3 4 5 6 | 1 2 3 4 5 6 | 1 2 3 4 5 6 |\n| 4             | 1 2 3 4 5   | 1 2 3 4 5   | 1 2 3 4 5 0 |\n| 5             | 1 2 3 4     | 1 2 3 5     | 1 2 3 0 4 0 |\n| 2             | 1 2 3       | 1 2 3       | 1 2 3 0 0 0 |\n| 1             | 1 2         | 1 3         | 1 0 2 0 0 0 |\n| 3             | 1           | 3           | 0 0 1 0 0 0 |\n-----------------------------------------------------------\n\nVariables preceded with _ use the internal variable indexation. Those without use the external/original variable indexation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.generate_function_expression-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.generate_function_expression","text":"generate_function_expression(function_name, sig, variables, body) -> Expr\n\n\nGenerate a function expression using Julia's metaprogramming capabilities\n\nExample\n\nfunction_name = :foo\nsig = (Int, Float64, Int32)\nvariables = [:a, :q, :d]\nbody = :(a + q * d)\n\nex = generate_function_expression(function_name, sig, variables, body)\n\neval(ex)\n\nfoo(1, 2.0, Int32(3))\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.get_induced_bag-Tuple{MetaGraphs.MetaGraph, Int64}","page":"Internals","title":"JunctionTrees.get_induced_bag","text":"get_induced_bag(g::MetaGraphs.MetaGraph, v::Int64) -> Any\n\n\nReturn the bag induced after removing v, i.e. the set of vars consisting of v and its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.get_induced_bag_weight-Tuple{MetaGraphs.MetaGraph, Int64, Any}","page":"Internals","title":"JunctionTrees.get_induced_bag_weight","text":"get_induced_bag_weight(g::MetaGraphs.MetaGraph, v::Int64, cards) -> Int64\n\n\nCompute the weight of the bag consisting of v and its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.initialize_td_graph!-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.initialize_td_graph!","text":"initialize_td_graph!(g, factors, smart_root_selection) -> Tuple{JunctionTrees.Node, Expr}\n\n\nInitialize the td graph by assigning the different factors to one bag that covers its scope.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus","text":"inject_redus(g, before_pass_pots, obsvars, obsvals) -> Expr\n\n\nInject a reduction expression to potentials that contain observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus-NTuple{6, Any}","page":"Internals","title":"JunctionTrees.inject_redus","text":"inject_redus(td, before_pass_pots, before_pass_forward_pass, before_pass_backward_pass, obsvars, obsvals) -> Tuple{Expr, Expr, Expr}\n\n\nInject a reduction expression to potentials that contain observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus_in_msgs-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus_in_msgs","text":"inject_redus_in_msgs(g, before_pass_msgs, obsvars, obsvals) -> Expr\n\n\nInject a reduction statement for each observed variable. Each reduction takes the observed variable and it's corresponding observed value. The reduction statements are introduced as late as possible, i.e. just before the observed variable is marginalized.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus_in_pots-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus_in_pots","text":"inject_redus_in_pots(g, before_pass_pots, obsvars, obsvals) -> Expr\n\n\nInject a reduction statement for observed variables contained inside isolated bags. An isolated bag is a leaf bag connected to the rest of the tree via one empty sepset. Each reduction takes the observed variable and it's corresponding observed value. \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.is_maximal-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.is_maximal","text":"is_maximal(candidate_clique, cliques) -> Bool\n\n\nReturn whether clique is maximal in the clique_set\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.mark_leaves!-Tuple{MetaGraphs.MetaGraph}","page":"Internals","title":"JunctionTrees.mark_leaves!","text":"mark_leaves!(g::MetaGraphs.MetaGraph) -> Any\n\n\nMark which nodes of g correspond to leaves using a property.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.mark_obsbags!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.mark_obsbags!","text":"mark_obsbags!(g, obsvars)\n\n\nMark which nodes of g have at least one observed variable.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.mass-Tuple{MetaGraphs.MetaGraph, Vector{Int64}}","page":"Internals","title":"JunctionTrees.mass","text":"mass(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}) -> Int64\n\n\nReturn the number of vars in the sepset.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.my_indexin-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.my_indexin","text":"my_indexin(x, y) -> Any\n\n\nOptimized version of the function indexin defined in Base.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_eval_analysis!-Tuple{Any}","page":"Internals","title":"JunctionTrees.partial_eval_analysis!","text":"partial_eval_analysis!(g)\n\n\nAnalyzes which messages can be computed during the compilation stage in the graph g.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_eval_prop_update!-NTuple{5, Any}","page":"Internals","title":"JunctionTrees.partial_eval_prop_update!","text":"partial_eval_prop_update!(g, curr_node, prev_node, obs_bag_var, obs_var_marginalized)\n\n\nRecursive function that invalidates messages in the graph g that cannot be partially evaluated at compile time. This marking is done using MetaGraphs' properties for each edge in the graph.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_evaluation-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.partial_evaluation","text":"partial_evaluation(td, pots, forward_pass, backward_pass) -> Tuple{Expr, Expr}\n\n\nPartially evaluates messages of the propagation stage that do not depend on online observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partially_evaluate-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.partially_evaluate","text":"partially_evaluate(g, before_pass_msgs) -> Expr\n\n\nPartially evaluate messages that do not depend on observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.preprocess_heap_elements-Tuple{MetaGraphs.MetaGraph, Any, Any, Any}","page":"Internals","title":"JunctionTrees.preprocess_heap_elements","text":"preprocess_heap_elements(g::MetaGraphs.MetaGraph, bag1, bag2, cards) -> NamedTuple{(:endpoints, :sepset, :key), _A} where _A<:Tuple{Tuple{Any, Any}, Any, Tuple{Int64, Int64}}\n\n\nCalculate the key for each element that will be inserted into the binary heap and wraps the edge, its sepset and the key into a tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_td_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_td_file","text":"read_td_file(td_filepath::String) -> Tuple{Int64, Int64, Int64, Vector{Vector{Int64}}, Vector{Vector{Int64}}}\n\n\nParse a tree decomposition instance described the PACE format.\n\nThe PACE file format is defined in: https://pacechallenge.org/2017/treewidth/\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_uai_evid_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_uai_evid_file","text":"read_uai_evid_file(uai_evid_filepath::String) -> Tuple{Vector{Int64}, Vector{Int64}}\n\n\nReturn the observed variables and values in uai_evid_filepath. If the passed file path is an empty string, return empty vectors.\n\nThe UAI file formats are defined in: https://personal.utdallas.edu/~vibhav.gogate/uai16-evaluation/uaiformat.html\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_uai_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_uai_file","text":"read_uai_file(uai_filepath::String) -> Tuple{Int64, Vector{Int64}, Int64, Any}\n\n\nParse the problem instance found in uai_filepath defined in the UAI model format.\n\nThe UAI file formats are defined in: https://personal.utdallas.edu/~vibhav.gogate/uai16-evaluation/uaiformat.html\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_uai_mar_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_uai_mar_file","text":"read_uai_mar_file(uai_mar_filepath::String) -> Vector{Vector{Float64}}\n\n\nReturn the marginals of all variables. The order of the variables is the same as in the model\n\nThe UAI file formats are defined in: https://personal.utdallas.edu/~vibhav.gogate/uai16-evaluation/uaiformat.html\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.select_rootnode-Tuple{Any}","page":"Internals","title":"JunctionTrees.select_rootnode","text":"select_rootnode(g; smart_root_selection) -> JunctionTrees.Node\n\n\nSelect and return the root node of g.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.weight-Tuple{Any, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.weight","text":"weight(g, bag::Vector{Int64}, cards) -> Int64\n\n\nCompute the product of the cardinalities of bag constituent vars.\n\n\n\n\n\n","category":"method"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The junction tree algorithm is an efficient method to perform Bayesian inference in probabilistic graphical models, such as Bayesian Networks or Markov random fields. The general problem is to calculate the conditional probability of a variable or a set of variables, given observed values of another set of variables. This is known as the inference problem.","category":"page"},{"location":"background/#The-inference-problem","page":"Background","title":"The inference problem","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Given a set of random variables bmV and their joint distribution P(bmV), compute one or more conditional distributions over a set of query variables bmQ given observations bme for the set of observed variables bmE.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    %\\draw[help lines] (0,0) grid (10,-7);\n\n    % mrv: the \"node distances\" refer to the distance between the edge of a shape\n    % to the edge of the other shape. That is why I use \"ie_aux\" and \"mar_aux\"\n    % below: to have equal distances between nodes with respect to the center of\n    % the shapes.\n\n    % row 1\n    \\node[myroundbox] (rv) {Random Variables\\\\$\\bm{V}$};\n    \\node[right=of rv](aux1) {};\n    \\node[right=of aux1,myroundbox] (jd) {Joint Distribution\\\\$P(\\bm{V})$};\n    \\node[right=of jd](aux2) {};\n    \\node[right=of aux2,myroundbox] (e) {Evidence\\\\$\\bm{E=e}$};\n    \\node[right=of e](aux3) {};\n    \\node[right=of aux3,myroundbox] (qv) {Query Variables\\\\$\\bm{Q}$};\n    % row 2\n    \\node[below=of aux2,myrectbox] (ie) {Inference Engine};\n    \\node[below=of aux2] (ie_aux) {};\n    % row 3\n    \\node[below=of ie_aux,myroundbox] (mar) {$P(\\bm{Q} \\mid {\\bf E=e})$};\n    \\node[below=of ie_aux] (mar_aux) {};\n    % row 0\n    \\node[above=of aux2,yshift=-12mm,text=black] (in) {\\textbf{Input}};\n    % row 4\n    \\node[below=of mar_aux,yshift=7mm,text=black] (out) {\\textbf{Output}};\n\n    %% edges\n    \\draw[myarrow] (rv) -- (ie);\n    \\draw[myarrow] (jd) -- (ie);\n    \\draw[myarrow] (e)  -- (ie);\n    \\draw[myarrow] (qv) -- (ie);\n    \\draw[myarrow] (ie) -- (mar);\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"the-inference-problem\") * \"}\",\n)\nsave(SVG(\"the-inference-problem\"), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#The-junction-tree-algorithm","page":"Background","title":"The junction tree algorithm","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"We briefly describe the junction tree algorithm (JTA). For a more elaborate presentation, see [huang1996inference]. The figure below presents an overview of the JTA.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    \\node[mybox] (pgm) {Probabilistic Graphical Model};\n    \\node[mybox,below=of pgm,yshift=-0.4cm] (jts) {Junction Tree};\n    \\node[mybox,below=of jts] (ijt) {Inconsistent Junction Tree};\n    \\node[mybox,below=of ijt,yshift=0.4cm] (cjt) {Consistent Junction Tree};\n    \\node[mybox,below=of ijt,yshift=0.4cm] (cjt) {Consistent Junction Tree};\n    \\node[text=black,below=of cjt] (mar) {$P(\\bm{Q} \\mid \\bm{E=e})$};\n\n    \\draw[myarrow] (pgm) -- (jts);\n    \\draw[myarrow] (jts) -- (ijt);\n    \\draw[myarrow] (ijt) -- (cjt);\n    \\draw[myarrow] (cjt) -- (mar);\n\n    \\path (pgm) -- node[mylabel] (gt) {1. Moralization\\\\2. Triangulation\\\\3. Connection of clusters} (jts);\n    \\path (jts) -- node[mylabel] (ini) {1. Initialization\\\\2. Observation entry} (ijt);\n    \\path (ijt) -- node[mylabel] (pro) {Propagation} (cjt);\n    \\path (cjt) -- node[mylabel] (mar-nor) {1. Marginalization\\\\2. Normalization} (mar);\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"pptc-flow-diagram\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"pptc-flow-diagram\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"A probabilistic graphical model (PGM) is the input to the JTA. PGMs illustrate the mathematical modeling of reasoning in the presence of uncertainty. Bayesian networks and Markov random fields are popular types of PGMs. Consider the Bayesian network shown in the figure below known as the ASIA network [lauritzen1988local]. It is a simplified example from the context of medical diagnosis that describes the probabilistic relationships between different random variables corresponding to possible diseases, symptoms, risk factors and test results. It consists of a graph G = (bmVmathcalE) and a probability distribution P(bmV) where G is a directed acyclic graph, bmV is the set of variables and mathcalE is the set of edges connecting the variables. We assume all variables to be discrete. Each variable V is quantified with a conditional probability distribution P(V mid pa(V)) where pa(V) are the parents of V. These conditional probability distributions together with the graph G induce a joint probability distribution over P(bmV), given by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"P(bmV) = prod_VinbmV P(V mid pa(V))","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Random variable Meaning\nA Recent trip to Asia\nT Patient has tuberculosis\nS Patient is a smoker\nL Patient has lung cancer\nB Patient has bronchitis\nE Patient hast T and/or L\nX Chest X-Ray is positive\nD Patient has dyspnoea","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    % The various elements are conveniently placed using a matrix:\n    \\matrix[row sep=0.5cm,column sep=0.5cm] {\n      % First line\n      \\node (a) [mybag] {$A$};  &\n                                &\n                                &\n      \\node (s) [mybag] {$S$};  &\n                               \\\\\n      % Second line\n      \\node (t) [mybag] {$T$};  &\n                                &\n      \\node (l) [mybag] {$L$};  &\n                                &\n      \\node (b) [mybag] {$B$}; \\\\\n      % Third line\n                                &\n      \\node (e) [mybag] {$E$};  &\n                                &\n                                &\n                               \\\\\n      % Forth line\n      \\node (x) [mybag] {$X$};  &\n                                &\n                                &\n      \\node (d) [mybag] {$D$};  &\n                               \\\\\n  };\n\n  \\draw [myarrow] (a) edge (t);\n  \\draw [myarrow] (s) edge (l);\n  \\draw [myarrow] (s) edge (b);\n  \\draw [myarrow] (t) edge (e);\n  \\draw [myarrow] (l) edge (e);\n  \\draw [myarrow] (e) edge (x);\n  \\draw [myarrow] (e) edge (d);\n  \\draw [myarrow] (b) edge (d);\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"asia\", \"bayesian-network\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"asia-bayesian-network\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Graphical-transformation","page":"Background","title":"Graphical transformation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"JTA performs probabilistic inference on a secondary structure known as a junction tree. A junction tree is constructed from a PGM by means of three graphical transformations: moralization, triangulation, and connection of clusters.","category":"page"},{"location":"background/#Moralization","page":"Background","title":"Moralization","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Moralization converts a directed acyclic graph into a undirected graph by dropping the directions of the edges and connecting the parents of each node. The figure below shows the corresponding moral graph of the Bayesian network in the figure above. The arrows point to the edges introduced after the transformation.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    \\matrix[row sep=0.5cm,column sep=0.5cm] {\n      % First line\n      \\node (a) [mybag, fill=A] {$A$};  &\n                                        &\n                                        &\n      \\node (s) [mybag, fill=S] {$S$};  &\n                                       \\\\\n      % Second line\n      \\node (t) [mybag, fill=T] {$T$};  &\n                                        &\n      \\node (l) [mybag, fill=L] {$L$};  &\n                                        &\n      \\node (b) [mybag, fill=B] {$B$}; \\\\\n      % Third line\n                                        &\n      \\node (e) [mybag, fill=E] {$E$};  &\n                                        &\n                                        &\n                                       \\\\\n      % Forth line\n      \\node (x) [mybag, fill=X] {$X$};  &\n                                        &\n                                        &\n      \\node (d) [mybag, fill=D] {$D$};  &\n                                       \\\\\n    };\n\n    \\draw (a) edge (t);\n    \\draw (s) edge (l);\n    \\draw (s) edge (b);\n    \\draw (t) edge (l); % <- added edge\n    \\draw (t) edge (e);\n    \\draw (l) edge (e);\n    \\draw (e) edge (x);\n    \\draw (e) edge (d);\n    \\draw (b) edge (e); % <- added edge\n    \\draw (b) edge (d);\n\n    \\path (t) -- node[anchor=center,xshift=-0.0cm,yshift=0.3cm,rotate=-90] (be) {$\\rightarrow$} (l);\n    \\path (b) -- node[anchor=center,xshift=0.2cm,yshift=-0.3cm,rotate=110] (be) {$\\rightarrow$} (e);\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"asia\", \"moral-graph\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"asia-moral-graph\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Triangulation","page":"Background","title":"Triangulation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Triangulation of an undirected graph is carried out by connecting two non-adjacent nodes in every cycle of length greater than three. The figure below shows a triangulated graph of the moral graph in the figure above. The arrow points to the edge introduced after the transformation. Note that, in general, there is more than one way of triangulating a given undirected graph. An optimal triangulation is one that minimizes the sum of the state space sizes of the maximal cliques[1] (denoted with colored boundaries in the figure below). This problem is NP-complete [arnborg1987complexity].","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    % The various elements are conveniently placed using a matrix:\n    \\matrix[row sep=0.5cm,column sep=0.5cm] {\n      % First line\n      \\node (a) [mybag] {$A$};  &\n                              &\n                              &\n      \\node (s) [mybag] {$S$};  &\n                            \\\\\n      % Second line\n      \\node (t) [mybag] {$T$};  &\n                              &\n      \\node (l) [mybag] {$L$};  &\n                              &\n      \\node (b) [mybag] {$B$}; \\\\\n      % Third line\n                              &\n      \\node (e) [mybag] {$E$};  &\n                              &\n                              &\n                            \\\\\n      % Forth line\n      \\node (x) [mybag] {$X$};  &\n                              &\n                              &\n      \\node (d) [mybag] {$D$};  &\n                            \\\\\n    };\n\n    \\draw (a) edge (t);\n    \\draw (s) edge (l);\n    \\draw (s) edge (b);\n    \\draw (t) edge (l);\n    \\draw (t) edge (e);\n    \\draw (l) edge (e);\n    \\draw (l) edge (b); % <- added edge\n    \\draw (e) edge (x);\n    \\draw (e) edge (d);\n    \\draw (b) edge (e);\n    \\draw (b) edge (d);\n\n    \\path (l) -- node[anchor=center,xshift=-0.15cm,yshift=-0.25cm,rotate=90] (bc) {$\\rightarrow$} (b);\n\n    \\draw[AT, myclique] \\convexpath{a,t}{15pt};\n    \\draw[TLE, myclique] \\convexpath{t,l,e}{15pt};\n    \\draw[EX, myclique] \\convexpath{e,x}{15pt};\n    \\draw[LBS, myclique] \\convexpath{l,s,b}{15pt};\n    \\draw[LBE, myclique] \\convexpath{l,b,e}{15pt};\n    \\draw[DEB, myclique] \\convexpath{d,e,b}{15pt};\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"asia\", \"triangulated-graph\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"asia-triangulated-graph\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Connection-of-clusters","page":"Background","title":"Connection of clusters","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The maximal cliques of the triangulated graph correspond to the nodes of the junction tree. We call these clusters. Clusters are then connected in a tree structure such that the running intersection property is satisfied: given two clusters bmX and bmY in the tree, all clusters on the path between bmX and bmY contain bmX cap bmY. Each edge is labeled with the intersection of the adjacent clusters. Such labels are called separator sets or sepsets. [jensen1994optimal] present an optimal method to construct a junction tree from a triangulated graph. The figure below shows the result of applying this method to the triangulated graph in the figure above. Clusters are depicted as large circles and sepsets as rectangles. The color of clusters correspond to the maximal cliques of the triangulated graph (figure above). The encircled variables indicate which conditional probability distributions in the equation presented in section The junction tree algorithm were multiplied into which cluster potentials of the junction tree.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    % The various elements are conveniently placed using a matrix:\n    \\matrix[row sep=0.26cm,column sep=0.20cm] {\n      % First line\n      \\node (lbs) [mybag, draw=LBS] {$\\{\\Circled[fill color=L]{L},\\Circled[fill color=B]{B},\\Circled[fill color=S]{S}\\}$};  &\n      \\node (lb) [myvsepset] {$\\{L,B\\}$};                            &\n      \\node (lbe) [mybag, draw=LBE] {$\\{L,B,E\\}$};  &\n      \\node (eb) [myvsepset] {$\\{E,B\\}$};                          &\n      \\node (deb) [mybag, draw=DEB] {$\\{\\Circled[fill color=D]{D},E,B\\}$}; \\\\\n      % Second line\n                                                          &\n                                                          &\n      \\node (le) [myhsepset] {$\\{L,E\\}$};                    &\n                                                          &\n                                                          \\\\\n      % Third line\n      \\node (at) [mybag, draw=AT] {$\\{\\Circled[fill color=A]{A},\\Circled[fill color=T]{T}\\}$};  &\n      \\node (t) [myvsepset] {$\\{T\\}$};                    &\n      \\node (tle) [mybag, draw=TLE] {$\\{T,L,\\Circled[fill color=E]{E}\\}$};  &\n      \\node (e) [myvsepset] {$\\{E\\}$};                    &\n      \\node (ex) [mybag,draw=EX] {$\\{E,\\Circled[fill color=X]{X}\\}$}; \\\\\n    };\n\n    % The diagram elements are now connected through lines:\n    \\path[-]\n      (lbs) edge (lb)\n      (lb) edge (lbe)\n      (lbe) edge (eb)\n      (eb) edge (deb)\n      (lbe) edge (le)\n      (le) edge (tle)\n      (at) edge (t)\n      (t) edge (tle)\n      (tle) edge (e)\n      (e) edge (ex)\n      ;\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"asia\", \"junction-tree\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"asia-junction-tree\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Initialization","page":"Background","title":"Initialization","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Each cluster bf X in the junction tree is associated with a potential psi_bf X. A potential is a function over a set of variables bmV that maps each instantiation bmV = bmv into a nonnegative number. First, all cluster potentials in the junction tree are initialized to unity. Then, each conditional probability distribution P(V mid pa(V)) in the equation presented in section The junction tree algorithm is multiplied into a cluster potential bf X that contains its variable and its parents:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"psi_bf X leftarrow psi_bf X cdot P(V mid pa(V))","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Note that a probability distribution is a special case of a potential. The encircled variables in the figure above indicate which conditional distributions in the Bayesian network figure were multiplied into which cluster potentials of our running example.","category":"page"},{"location":"background/#Observation-entry","page":"Background","title":"Observation entry","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Observations take the form of bf E=e, where bf e is the instantiation of the set of variables bf E. These are incorporated into the junction tree by finding a cluster potential psi_bf X for each evidence variable in bf E that contains it and setting all its entries that are not consistent with the evidence to zero. This operation is known as a reduction in the PGM literature [koller2009probabilistic].","category":"page"},{"location":"background/#Propagation","page":"Background","title":"Propagation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Propagation refers to a series of synchronized local manipulations between clusters that guarantee consistency throughout the entire junction tree. These manipulations are called messages. The propagation of messages begins by designating an arbitrary cluster as the root, which gives direction to the edges of the junction tree. Messages then flow between clusters in two recursive phases: an inward and an outward phase. In the inward phase, each cluster passes a message to its parent. In the outward phase, each cluster passes a message to each of its children. A cluster passes a message to a neighbor only after it has received messages from all its other neighbors. A message from cluster bf X to cluster bf Y is a potential phi_bf X rightarrow bf Y defined by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"phi_bf X rightarrow bf Y =\nsum_bf X setminus bf Y psi_bf X prod_bf N in\nmathcalN_bf X setminus bf Y phi_bf N rightarrow bf X","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where psi_bf X is the cluster potential of bf X and mathcalN_bf X is the set of neighbors of bf X. The figure below shows an admissible schedule for the propagation of messages of our running example.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    % The various elements are conveniently placed using a matrix:\n    \\matrix[row sep=1.0cm,column sep=1.0cm] {\n      % First line\n      \\node (lbs) [mybag, label={below:{Root}}] {$\\{L,B,S\\}$};  &\n      \\node (lbe) [mybag] {$\\{L,B,E\\}$};                        &\n      \\node (deb) [mybag] {$\\{D,E,B\\}$};                       \\\\\n      % Second line\n      \\node (at) [mybag] {$\\{A,T\\}$};                           &\n      \\node (tle) [mybag] {$\\{T,L,E\\}$};                        &\n      \\node (ex) [mybag] {$\\{E,X\\}$};                          \\\\\n    };\n      \n    % The diagram elements are now connected through lines:\n    \\path[-]\n      (lbs) edge (lbe)\n      (lbe) edge (deb)\n      (lbe) edge (tle)\n      (at) edge (tle)\n      (tle) edge (ex)\n      ;\n\n    \\msgcircle{up}{right}{at}{tle}{0.5}{$1$}{IP};\n    \\msgcircle{up}{left}{ex}{tle}{0.5}{$2$}{IP};\n    \\msgcircle{left}{up}{tle}{lbe}{0.5}{$3$}{IP};\n    \\msgcircle{up}{left}{deb}{lbe}{0.5}{$4$}{IP};\n    \\msgcircle{up}{left}{lbe}{lbs}{0.5}{$5$}{IP};\n    \\msgcircle{down}{right}{lbs}{lbe}{0.5}{$6$}{OP};\n    \\msgcircle{right}{down}{lbe}{tle}{0.5}{$7$}{OP};\n    \\msgcircle{down}{right}{lbe}{deb}{0.5}{$8$}{OP};\n    \\msgcircle{down}{left}{tle}{at}{0.5}{$9$}{OP};\n    \\msgcircle{down}{right}{tle}{ex}{0.5}{$10$}{OP};\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"asia\", \"message-passing\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"asia-message-passing\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Marginalization","page":"Background","title":"Marginalization","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"After the propagation phase, each edge holds two messages; one in each direction. The joint marginal probabilities for each sepset are given by the product of the two messages passing through the corresponding edge, i.e.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"P(S_bf Xbf Y bf E=e) = phi_bf X rightarrow bf Y cdot\n  phi_bf Y rightarrow bf X","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bf X and bf Y are adjacent clusters. On the other hand, the joint marginal probabilities for each cluster are given by the product of the cluster's incoming messages and its potential, i.e.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"P(bf X bf E=e) = psi_bf X prod_bf N in mathcalN_bf\nX phi_bf N rightarrow bf X","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The marginal probability P(Vbf E=e) for each variable of interest V is then computed from the joint marginal of a sepset or cluster containing V. This is achieved by marginalizing all other variables:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"P(Vbf E=e) = sum_bf X^prime setminus V P(bf X^prime bf\nE=e)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bf X^prime is a sepset or cluster potential that contains V.","category":"page"},{"location":"background/#Normalization","page":"Background","title":"Normalization","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The last step is to compute P(V mid bf E=e) for each variable of interest V. We do so by normalizing P(V bf E=e):","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"P(V mid bf E=e) = fracP(V bf E=e)sum_V P(V bf E=e)","category":"page"},{"location":"background/#Compiler-based-framework","page":"Background","title":"Compiler-based framework","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"JunctionTrees.jl exploits Julia's metaprogramming capabilities to separate the algorithm into two phases: a compilation and a runtime phase. The compilation phase consists of the creation and subsequent optimization of the algorithm. The run-time phase consists of processing online data with the compiled algorithm to provide answers about variables of interest. This distinction between a compilation and a runtime phase opens a wide range of optimization possibilities in the offline stage. The figure below illustrates the compiler-based framework design used in JunctionTrees.jl.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"using TikzPictures\n\ntp = TikzPicture(\n  L\"\"\"\n    %\\draw[help lines] (0,0) grid (7,-9);\n\n    %\\draw [thick] (-1.5, 0.6) rectangle (7.3, -7.45);\n    \\draw [dashed,draw=black,line width=2pt] (-7.8, -4.8) -- (2.4, -4.8);\n\n    \\node [above,yshift=4.0pt,text=black] at (-7.2, -4.75) {Off-line};\n    \\node [below,yshift=-4.0pt,text=black] at (-7.2, -4.85) {On-line};\n\n    % row 1\n    \\node[myroundbox] (pgm) {PGM};\n    \\node[myroundbox,left=of pgm] (qv) {Query Vars};\n    % row 2\n    \\node[myrectbox,below=of pgm] (pptc) {JTA};\n    % row 3\n    \\node[myroundbox,below=of pptc] (sup) {Subject Program};\n    \\node[myroundbox,left=of sup] (evv) {Evidence Vars};\n    % row 4\n    \\node[myrectbox,below=of sup] (pe) {Optimization};\n    % row 5\n    \\node[myroundbox,below=of pe,yshift=-8mm] (spp) {Optimized Program};\n    \\node[myroundbox,left=of spp] (ev) {Evidence Values};\n    % row 6\n    \\node[myroundbox,below=of spp] (mar) {$P(\\text{Query Vars} \\mid {\\bf E=e})$};\n    % edges\n    \\draw[myarrow] (pgm) -- (pptc);\n    \\draw[myarrow] (qv) -- (pptc);\n    \\draw[myarrow] (pptc) -- (sup);\n    \\draw[myarrow] (sup) -- (pe);\n    \\draw[myarrow] (evv) -- (pe);\n    \\draw[myarrow] (pe) -- (spp);\n    \\draw[myarrow] (ev) -- (spp);\n    \\draw[myarrow] (spp) -- (mar);\n  \"\"\",\n  options=\"transform shape, scale=1.4\",\n  preamble=\"\\\\input{\" * joinpath(@__DIR__, \"assets\", \"compiler-based-framework\") * \"}\",\n)\nsave(SVG(joinpath(@__DIR__, \"compiler-based-framework\")), tp)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[1]: A clique in an undirected graph is a subgraph in which every pair of nodes is connected by an edge. A maximal clique is a clique that is not contained in a larger clique.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[huang1996inference]: Cecil Huang and Adnan Darwiche. Inference in belief networks: A procedural guide. International Journal of Approximate Reasoning, 15 (3):225–263, 1996. ISSN 0888-613X. doi: https://doi.org/10.1016/S0888-613X(96)00069-2. URL https://www.sciencedirect.com/science/article/pii/S0888613X96000692.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[lauritzen1988local]: Steffen L Lauritzen and David J Spiegelhalter. Local computations with probabilities on graphical structures and their application to expert systems. Journal of the Royal Statistical Society: Series B (Methodological), 50(2):157–194, 1988.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[arnborg1987complexity]: Stefan Arnborg, Derek G Corneil, and Andrzej Proskurowski. Complexity of finding embeddings in ak-tree. SIAM Journal on Algebraic Discrete Methods, 8(2):277–284, 1987.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[jensen1994optimal]: Finn V. Jensen and Frank Jensen. Optimal junction trees. In Proceedings of the Tenth International Conference on Uncertainty in Artificial Intelligence, UAI’94, page 360–366, San Francisco, CA, USA, 1994. Morgan Kaufmann Publishers Inc. ISBN 1558603328.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[koller2009probabilistic]: Daphne Koller and Nir Friedman. Probabilistic graphical models: principles and techniques, pg 111. MIT press, 2009.","category":"page"},{"location":"#JunctionTrees.jl","page":"Home","title":"JunctionTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A metaprogramming-based implementation of the junction tree algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"left\">\n<img width=\"600px\" src=\"./problems/Promedus_34/Promedus_34.svg\" alt=\"Junction tree example\"></img>\n</div>","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Posterior marginal computation of discrete variables given evidence.\nMetaprogramming-based design that separates the algorithm into a compilation and a runtime phase.\nVisualization of junction trees, Bayesian networks and Markov random fields.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"background.md\",\n  \"usage.md\",\n  \"visualization/junction_trees.md\",\n  \"visualization/markov_random_fields.md\",\n  \"file_formats/uai.md\",\n  \"file_formats/pace.md\",\n  \"library/public.md\",\n  \"library/internals.md\",\n]\nDepth = 1","category":"page"},{"location":"file_formats/uai/#UAI-file-formats","page":"UAI","title":"UAI file formats","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"This document defines the following file formats:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"UAI model file format.\nUAI evidence file format.\nUAI results file format.","category":"page"},{"location":"file_formats/uai/#UAI-model-file-format","page":"UAI","title":"UAI model file format","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"We use the simple text file format specified below to describe problem instances (Markov networks). The format is a generalization of the Ergo file format initially developed by Noetic Systems Inc. for their Ergo software. We use the .uai suffix for the evaluation benchmark network files.","category":"page"},{"location":"file_formats/uai/#Structure","page":"UAI","title":"Structure","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"A file in the UAI format consists of the following two parts, in that order:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"<Preamble>\n\n<Function tables>","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The contents of each section (denoted <...> above) are described in the following:","category":"page"},{"location":"file_formats/uai/#Preamble","page":"UAI","title":"Preamble","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Our description of the format will follow a simple Markov network with three variables and two functions. A sample preamble for such a network is:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"MARKOV\n3\n2 2 3\n2\n2 0 1\n2 1 2","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The preamble starts with one line denoting the type of network. Generally, this can be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network). However, note that this year all networks will be given in a Markov networks (i.e. Bayesian networks will be moralized).","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The second line contains the number of variables. The next line specifies the cardinalities of each variable, one at a time, separated by a whitespace (note that this implies an order on the variables which will be used throughout the file). The fourth line contains only one integer, denoting the number of cliques in the problem. Then, one clique per line, the scope of each clique is given as follows: The first integer in each line specifies the number of variables in the clique, followed by the actual indexes of the variables. The order of this list is not restricted. Note that the ordering of variables within a factor will follow the order provided here.","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Referring to the example above, the first line denotes the Markov network, the second line tells us the problem consists of three variables, let's refer to them as X, Y, and Z. Their cardinalities are 2, 2, and 3 respectively (from the third line). Line four specifies that there are 2 cliques. The first clique is X,Y, while the second clique is Y,Z. Note that variables are indexed starting with 0.","category":"page"},{"location":"file_formats/uai/#Function-tables","page":"UAI","title":"Function tables","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"In this section each factor is specified by giving its full table (i.e, specifying value for each assignment). The order of the factor is identical to the one in which they were introduced in the preamble, the first variable have the role of the 'most significant' digit. For each factor table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the function's scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the 'least significant'. To illustrate, we continue with our Markov network example from above, let's assume the following conditional probability tables:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"X     P(X)\n0     0.436\n1     0.564\n\nX Y   P(Y,X)\n0 0   0.128\n0 1   0.872\n1 0   0.920\n1 1   0.080\n\nY Z   P(Z,Y)\n0 0   0.210\n0 1   0.333\n0 2   0.457\n1 0   0.811\n1 1   0.000\n1 2   0.189","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The corresponding function tables in the file would then look like this:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"2\n0.436 0.564\n\n4\n0.128 0.872\n0.920 0.080\n\n6\n0.210 0.333 0.457\n0.811 0.000 0.189","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"(Note that line breaks and empty lines are effectively just a whitespace, exactly like plain spaces \" \". They are used here to improve readability.)","category":"page"},{"location":"file_formats/uai/#Summary","page":"UAI","title":"Summary","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"To sum up, a problem file consists of 2 sections: the preamble and the full the function tables, the names and the labels. For our Markov network example above, the full file will look like:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"MARKOV\n3\n2 2 3\n3\n1 0\n2 0 1\n2 1 2\n\n2\n0.436 0.564\n\n4\n0.128 0.872\n0.920 0.080\n\n6\n0.210 0.333 0.457\n0.811 0.000 0.189","category":"page"},{"location":"file_formats/uai/#UAI-evidence-file-format","page":"UAI","title":"UAI evidence file format","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Evidence is specified in a separate file. This file has the same name as the original network file but with an added .evid suffix. For instance, problem.uai will have evidence in problem.uai.evid. The file starts with a line specifying the number of evidences samples. The evidence in each sample, will be written in a new line. Each line will begin with the number of observed variables in the sample, followed by pairs of variable and its observed value. The indexes correspond to the ones implied by the original problem file. If, for our above example, we want to provide a single sample where the variable Y   has been observed as having its first value and Z with its second value, the   file example.uai.evid would contain the following:","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"1\n2 1 0 2 1","category":"page"},{"location":"file_formats/uai/#UAI-results-file-format","page":"UAI","title":"UAI results file format","text":"","category":"section"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The first line must contain only the task solved: PR|MPE|MAR|BEL. The rest of the file will contain the solution for the task. Solvers can write more then one solution by writing -BEGIN- at the head of the new solution. We will only consider the last solution in the file. In the example below the task we choose is PR. We have two solutions. The format of the <SOLUTION> part will be described below.","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"PR\n<SOLUTION>\n-BEGIN-\n<SOLUTION>","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The first line in each solution will contain the number of evidence samples. This will be the number of lines (not include this line) in the solution part. Hence each line from here will contain the solution with a different sample of evidence - ordered as in the evidence file. If there is no evidence (the first line of the evidence file is 0), the output should include the results for the empty evidence scenario. This is regarded as a single-evidence case - one with the empty evidence.","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Solvers that can bound their estimation are encouraged to specify if their solution is lower or upper bound. Doing so by adding at the end of the solution the letters L (for lower bound) or U (for upper bound).","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"The line format is as follows (according to the task):","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Partition function, PR: Line with the value of the log10 of the partition function. For example, an approximation log10 Pr(e) = -0.2008 which is known to be an upper bound may have a solution line:\n-0.2008 U\nMost probable explanation, MPE: A space separated line that includes:\nthe number n of model variables, and\nthe MPE instantiation, a list of value indices for all n variables.\nFor example, an input model with 3 binary variables may have a solution line:\n3 0 1 0\nMarginals, MAR: A space separated line that includes:\nThe number of variables in the model.\nA list of marginal approximations of all the variables. For each variable its cardinality is first stated, then the probability of each state is stated. The order of the variables is the same as in the model, all data is space separated.\nFor example, a model with 3 variables, with cardinalities of 2, 2, 3 respectively. The solution might look like this:\n3 2 0.1 0.9 2 0.3 0.7 3 0.2 0.2 0.6\nBeliefs, BEL: A space separated line that includes:\nThe number n of model cliques, and\nA list of belief approximations for all n cliques. Each marginal approximation is specified by a list, starting with the number of entries of the factor, followed by the approximation Pr(xe) for each value of x (where is a vector of the clique variables).\nFor example, if an input model has 2 cliques the first with 2 binary variable and the second with 3. The solution line may look like:\n2 4 0.25 0.25 0.4 0.1 8 0.1 0.05 0.05 0.2 0.1 0.01 0.04 0.45\nThe order of the entries is as in the model description.","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"Here is a complete example for a solution for the MPE task. The evidence file contains one evidence samples.","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"MPE\n1\n4 0 2 0 4\n-BEGIN-\n1\n4 0 2 0 4","category":"page"},{"location":"file_formats/uai/","page":"UAI","title":"UAI","text":"If a solver does not produce a solution by the given time, it would be considered as having failed on the instance. This will be treated as equivalent to a naive solution (e.g. bit-wise singleton clique maximum for a MAP problem).","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for JunctionTrees.jl's public interface.","category":"page"},{"location":"library/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nOrder   = [:module]","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Types","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nOrder   = [:type]","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Functions","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nOrder   = [:function]","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Constants","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nOrder   = [:constant]","category":"page"},{"location":"library/public/#Public-interface","page":"Public","title":"Public interface","text":"","category":"section"},{"location":"library/public/#Modules","page":"Public","title":"Modules","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"JunctionTrees","category":"page"},{"location":"library/public/#JunctionTrees","page":"Public","title":"JunctionTrees","text":"Main module for JunctionTrees.jl – a Julia implementation of the junction tree algorithm.\n\nOne main function is exported from this module for public use:\n\ncompile_algo. Compiles and returns an expression that computes the posterior marginals of the model given evidence using the junction tree algorithm.\n\nExports\n\nBackwardPass\nFactor\nForwardPass\nJointMarginals\nLastStage\nMarginals\nUnnormalizedMarginals\ncompile_algo\nnorm\nprod\nredu\nsum\n\n\n\n\n\n","category":"module"},{"location":"library/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Factor\nLastStage","category":"page"},{"location":"library/public/#JunctionTrees.Factor","page":"Public","title":"JunctionTrees.Factor","text":"struct Factor{T, N}\n\nFields\n\nvars\nvals\n\nEncodes a discrete function over the set of variables vars that maps each instantiation of vars into a nonnegative number in vals.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JunctionTrees.LastStage","page":"Public","title":"JunctionTrees.LastStage","text":"Enumerated type used to select up to which stage an expression of the junction tree algorithm should be returned after calling compile_algo.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Functions","page":"Public","title":"Functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"compile_algo\nprod\nsum\nredu\nnorm","category":"page"},{"location":"library/public/#JunctionTrees.compile_algo","page":"Public","title":"JunctionTrees.compile_algo","text":"compile_algo(uai_filepath::String; uai_evid_filepath, td_filepath, apply_partial_evaluation, last_stage, smart_root_selection) -> Expr\n\n\nReturn an expression of the junction tree algorithm that extracts the marginals of all the variables in the model.\n\nArguments\n\nuai_filepath::String: path to the model file defined in the UAI model file format.\nuai_evid_filepath::String = \"\": path to the evidence file defined in the UAI evidence file format.\ntd_filepath::String = \"\": path to a pre-constructed junction tree defined in the PACE graph format.\napply_partial_evaluation::Bool = false: optimize the algorithm using partial evaluation.\nlast_stage::LastStage = Marginals: return an expression up to the given stage. The options are ForwardPass, BackwardPass, JointMarginals, UnnormalizedMarginals and Marginals.\nsmart_root_selection::Bool = select as root the cluster with the largest state space.\n\nExamples\n\nalgo = compile_algo(\"../examples/problems/paskin/paskin.uai\")\neval(algo)\nobsvars, obsvals = Int64[], Int64[]\nmarginals = run_algo(obsvars, obsvals)\n\n# output\n\n6-element Vector{Factor{Float64, 1}}:\n Factor{Float64, 1}((1,), [0.33480077287635474, 0.33039845424729053, 0.33480077287635474])\n Factor{Float64, 1}((2,), [0.378700415763991, 0.621299584236009])\n Factor{Float64, 1}((3,), [0.3632859624875086, 0.6367140375124913])\n Factor{Float64, 1}((4,), [0.6200692707149191, 0.37993072928508087])\n Factor{Float64, 1}((5,), [0.649200314859223, 0.350799685140777])\n Factor{Float64, 1}((6,), [0.5968155611613972, 0.4031844388386027])\n\nalgo = compile_algo(\n         \"../examples/problems/paskin/paskin.uai\",\n         uai_evid_filepath = \"../examples/problems/paskin/paskin.uai.evid\")\neval(algo)\nobsvars, obsvals = JunctionTrees.read_uai_evid_file(\"../examples/problems/paskin/paskin.uai.evid\")\nmarginals = run_algo(obsvars, obsvals)\n\n# output\n\n6-element Vector{Factor{Float64, 1}}:\n Factor{Float64, 1}((1,), [1.0, 0.0, 0.0])\n Factor{Float64, 1}((2,), [0.0959432982733719, 0.9040567017266281])\n Factor{Float64, 1}((3,), [0.07863089300137578, 0.9213691069986242])\n Factor{Float64, 1}((4,), [0.8440129077674895, 0.15598709223251056])\n Factor{Float64, 1}((5,), [0.9015456486772953, 0.09845435132270475])\n Factor{Float64, 1}((6,), [0.6118571666785584, 0.3881428333214415])\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Base.prod","page":"Public","title":"Base.prod","text":"prod(A::Factor{T}, B::Factor{T}) -> Factor\n\n\nCompute a factor product of tables A and B.\n\nExamples\n\nA = Factor{Float64,2}((2, 3), [0.5 0.7; 0.1 0.2])\nB = Factor{Float64,2}((1, 2), [0.5 0.8; 0.1 0.0; 0.3 0.9])\nprod(A, B)\n\n# output\n\nFactor{Float64, 3}((1, 2, 3), [0.25 0.08000000000000002; 0.05 0.0; 0.15 0.09000000000000001;;; 0.35 0.16000000000000003; 0.06999999999999999 0.0; 0.21 0.18000000000000002])\n\n\n\n\n\nprod(F::Factor{T}...) -> Factor\n\n\nCompute a factor product of an arbitrary number of factors.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Base.sum","page":"Public","title":"Base.sum","text":"sum(A::Factor{T, ND}, V::Tuple{Vararg{Int64, N}} where N) -> Factor\n\n\nSum out the variables in V from factor A.\n\nExamples\n\nA = Factor{Float64,2}((1, 2), [0.59 0.41; 0.22 0.78])\nsum(A, (2,))\n\n# output\n\nFactor{Float64, 1}((1,), [1.0, 1.0])\n\n\n\n\n\nsum(A::Factor, V::Int64...) -> Factor\n\n\nSum out an arbitrary number of variables from factor A.\n\nExamples\n\nA = Factor{Float64,3}((1, 2, 3), cat([0.25 0.08; 0.05 0.0; 0.15 0.09],\n                                     [0.35 0.16; 0.07 0.0; 0.21 0.18], dims=3))\nsum(A, 1, 2)\n\n# output\n\nFactor{Float64, 1}((3,), [0.6199999999999999, 0.97])\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.redu","page":"Public","title":"JunctionTrees.redu","text":"redu(A::Factor{T}, vars::Tuple, vals::Tuple) -> Factor\n\n\nReduce/invalidate all entries in A that are not consitent with the evidence passed in vars and vals, where each variable in vars is assigned the corresponding value in vals.\n\nExamples\n\nA = Factor{Float64,3}((1, 2, 3), cat([0.25 0.08; 0.05 0.0; 0.15 0.09],\n                                     [0.35 0.16; 0.07 0.0; 0.21 0.18], dims=3))\nobs_vars = (3,)\nobs_vals = (1,)\nredu(A, obs_vars, obs_vals)\n\n# output\n\nFactor{Float64, 3}((1, 2, 3), [0.25 0.08; 0.05 0.0; 0.15 0.09;;; 0.0 0.0; 0.0 0.0; 0.0 0.0])\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.norm","page":"Public","title":"JunctionTrees.norm","text":"norm(A::Factor) -> Factor\n\n\nNormalize the values in Factor A such they sum up to 1.\n\nExamples\n\nA = Factor{Float64,2}((1, 2), [0.2 0.4; 0.6 0.8])\nnorm(A)\n\n# output\n\nFactor{Float64, 2}((1, 2), [0.1 0.2; 0.3 0.4])\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Constants","page":"Public","title":"Constants","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"ForwardPass\nBackwardPass\nJointMarginals\nUnnormalizedMarginals\nMarginals","category":"page"},{"location":"library/public/#JunctionTrees.ForwardPass","page":"Public","title":"JunctionTrees.ForwardPass","text":"When assigned to the keyword argument last_stage of compile_algo, an expression up to and including the forward pass is returned.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.BackwardPass","page":"Public","title":"JunctionTrees.BackwardPass","text":"When assigned to the keyword argument last_stage of compile_algo, an expression up to and including the backward pass is returned.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.JointMarginals","page":"Public","title":"JunctionTrees.JointMarginals","text":"When assigned to the keyword argument last_stage of compile_algo, an expression that computes the cluster joint marginals is returned.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.UnnormalizedMarginals","page":"Public","title":"JunctionTrees.UnnormalizedMarginals","text":"When assigned to the keyword argument last_stage of compile_algo, an expression that computes the joint marginals is returned.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.Marginals","page":"Public","title":"JunctionTrees.Marginals","text":"When assigned to the keyword argument last_stage of compile_algo, an expression that computes the posterior marginals is returned (default).\n\n\n\n\n\n","category":"constant"}]
}
